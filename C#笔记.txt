Visual Studio 2019 一键注释：ctrl+k+v
--------------------------------------------------------------------------------------------------------------------------------------------------------
1.out关键字的使用，用方法的参数 用作返回值
总结：简单来说，out修饰的变量，在函数内进行赋值的时候，就会调用函数的时候，在函数内赋值的值就会被带出来，如果没有out修饰的变量的话，
你直接赋值的话是改变不了原来定义的值的。并且要确保out的值能够被返回。

 public static void method(out int b, out String c)
        {
            b = 1000;
            c = "adv";
        }

        static void Main(string[] args)
        {
            int p=1;
            String q="xooos";//两个实参

            method(out p,out q);

            WriteLine(p);//1000
            WriteLine(q);//adv

        }
--------------------------------------------------------------------------------------------------------------------------------------------------------
2.ref关键字：作用：给形参前面加一个ref,可以将外部变量带入到函数中进行赋值改变，然后将改变后的值在传出来赋值给传进来的变量名，ref参数要求变量外部必须赋值，方法内部可以不赋值
 class Program
    {

        public static void method(ref int bb)

        {
            bb = 1000;//形参为1000

        } 


        static void Main(string[] args)
        {   	
            int b = 100; //b的值先为100
            
            method(ref b);//加上ref了 形参值为1000居然传递给了实参b

            Write(b);//结果为1000

         }

    }
//总结out和ref的区别： 	1.out和ref核心是能为方法提供多个返回值。
			
			2.相同之处： 经过方法调用后，都可以改变外部的变量的值，在函数内进行赋值都可以把值给带出来，最终结果都是 传入的实参值改变了。

		   	3.不同之处：out可以不定义初始值，但是在函数里面必须确保要赋值，要保证有值返回。 ref是必须要赋初始值的，函数内部可用可不用赋值。


--------------------------------------------------------------------------------------------------------------------------------------------------------
3.C# 可空类型（Nullable）：C# 提供了一个特殊的数据类型，nullable 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。比如： int？。

Null 合并运算符（ ?? ）：

    C# 中两个问号的作用是  判断??左边的对象是否为 null， 如果不为 null 则使用 ?? 左边的对象， 如果为 null 则使用 ?? 右边的对象。
	比如：
	a = b ?? c
	如果 b 为 null，则 a = c，如果 b 不为 null，则 a = b。
	

--------------------------------------------------------------------------------------------------------------------------------------------------------
4.C#数据类型-枚举；

每个枚举都对应一个底层的整型数值（Enum.GetUnderlyingType()）

里面的每个元素都默认基础类型是int

默认第一个值是0，后续每一项都递增1

也可以指定其它类型（可以是除char之外的任意整型），例如byte

class Program
    {
        public enum enum1:byte //enum1表示多个整形值的集合，里面的每一个元素都是整形
        {
            a,
            b=100,
            c,
            d
        }

        static void Main(string[] args)
        {
            WriteLine((int)enum1.a);//0
            WriteLine((int)enum1.b);//100
            WriteLine((int)enum1.c);//101
            WriteLine((int)enum1.d);//102
        }

    }

--------------------------------------------------------------------------------------------------------------------------------------------------------
5.使用partial关键字可以声明部分类， 部分类的作用是 可以在多个文件中声明同一个类， 主要用于类比较大的时候进行拆分，或者xaml中使用也比较多。

例如：创建3个.cs文件，分别是 Name.cs Age.cs Sex.cs

三个文件中都是在声明同一个类 MyClass中。 

不要把部分类以为是定义了多个类，其实还是一个类，只是把这个类拆分了。 在程序运行的时候编译器会把这个类合并在一起的， 这样做的好处是，

当你有一个类很大的时候你可以按实现功能拆分在不同的文件中，这样就方便阅读和修改了

--------------------------------------------------------------------------------------------------------------------------------------------------------
6.
C# 在 3.0 版本中提供了对 扩展方法 的支持，扩展方法  常用于给一个已存在的类添加新的方法从而扩展该类的功能，最关键的是：你不需要在现存类中派生一个子类，你也不需要破坏性的修改类的现有代码骨架，

更谈不上重新编译了，扩展方法能够提供代码的可读性同时又可以扩展类的功能。

你可以用这项技术去给已存在的 class 或者 interface 添加更多实用方法而不应该从子类中新增额外的方法，MSDN上说：扩展方法允许你给现有的类 添加 方法，而不需要你生成子类，重新编译，

或者任何其他形式的修改原有类，扩展方法是一种特殊的静态方法，当你调用它的时候就好像它就是你扩展类的原生方法。

本质上来说，扩展方法也算是一种特殊的静态方法，它允许你给已存在的类添加新的方法即使你没有权限访问这个扩展类的源代码，扩展方法除了签名中的第一个参数是 this 之外就和静态方法是一模一样，你可以给任何一个类

添加任意多的扩展方法，更🐂👃的是：这个扩展方法特性还可以作用到值类型之上。

当你使用扩展方法的时候，请记住下面的几个点：

1.扩展方法必须是一个静态方法

2.扩展方法必须在 static class 内，类的名字无所谓

3.扩展方法的第一个参数一定是 this，后面跟上你需要扩展的类型// 这点很重要，this后的类型 就会拥有该扩展方法。

4.有一点要特别注意，如果扩展方法的名字和你要扩展类中的某一个方法重名了，那么你的扩展方法将会失效，永远也不会被调用。

例子：
public static class IntegerExtensions //扩展方法所在类必须是static方法
    {
        public static bool IsEven(this int i)//this后的该int型 就会拥有 IsEven()方法。此时的int i不表示形参，不需要传参数，相当于一个标志。
        {
            return ((i % 2) == 0);
        }
    }

static void Main(string[] args)
        {
            int n = 2;

            if (n.IsEven())  //此时，int 型已经拥有了IsEven()方法
	    Console.WriteLine("The value of the integer is even.");
        }
-------------------------------------------------
再如： ======================>核心是 必须在static类中的static扩展方法的第一个参数上 用this指定需要扩展方法的类<===========================
public  class Myclass //这是一个需要扩展方法的Myclass类，只有method1方法
{
    public void method1()
    {
        Write("method1");
    }

}

public static class Extesion//扩展类里面有扩展方法method2
{
    public static void  method2(this Myclass m)//this指定method方法可以扩展至 Myclass类
    {
        Write("method2");
    }
}

namespace ConsoleApp1
{
    static class Program
    {

        static void Main(string[] args)
        {
            Myclass myclass = new Myclass();

            myclass.method2();	//测试Myclass类已有method2()方法
            
         }

    }
}


--------------------------------------------------------------------------------------------------------------------------------------------------------
7.结构：
struct Books
{
   public string title;
   public string author;
   public string subject;
   public int book_id;
}; 

Books Book1;        //声明 Book1，类型为 Books,不需要new也可实例化，但必须要有初始化值 。
Books Book2;        // 声明 Book2，类型为 Books 

/* book 1 详述 */
Book1.title = "C Programming";
Book1.author = "Nuha Ali";
Book1.subject = "C Programming Tutorial";
Book1.book_id = 6495407;

已经用了一个简单的名为 Books 的结构。在 C# 中的结构与传统的 C 或 C++ 中的结构不同。C# 中的结构有以下特点：

结构可带有方法、字段、索引、属性、运算符方法和事件。

结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。

与类不同，结构不能继承其他的结构或类。

结构不能作为其他结构或类的基础结构。

结构可实现一个或多个接口。

结构成员不能指定为 abstract、virtual 或 protected。

当您使用 New 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。

如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。

类和结构有以下几个基本的不同点：

类是引用类型，结构是值类型。
结构不支持继承。
结构不能声明默认的构造函数。

补：base == super 且 sealed == final
--------------------------------------------------------------------------------------------------------------------------------------------------------
8.构造器
public class Father//父类
{
    public Father(){
        WriteLine("父类");
    }
}
public  class Myclass:Father //子类继承父类
{
    public Myclass() : base() //调用父类的无参构造器，在这里写与不写一样。注意格式
    {
        WriteLine("子类");
    }
}

---------------------------------------------------
public class Father//父类
{
    int age;
    String name;

    public Father(int age,String name){
        this.age = age;
        this.name = name;
    }
}

public  class Myclass:Father//子类继承父类
{
    public int age;
    public String name;

    public Myclass(int age, String name) : base(age,name)//调用父类的构造器，注意格式
    {
        this.name = name;
        this.age = age;
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------
9.is和as关键字：
is ：判断检查对象是否与给定类型兼容（等于instance of）         A is B --->A实例是否是B类型

as ：将对象转换为指定类型（强转），就跟（int ）这样的用法是一样的。在内部，as关键字是这么处理的，  instace is type ? (type)instance : (type)null ===》是该类型才强转，不是则返回null。
--------------------------------------------------------
is的使用：
class Manager : Person { //继承
}
Manager m = new Manager();//子类
bool result = m is Person;

interface IEmpty { //接口
}
class ImplememntEmpty : IEmpty { //实现接口
}
ImplememntEmpty instance = new ImplememntEmpty();//子类
var result = instance is IEmpty;

as的使用1：
object obj = 10l;
var result = obj as long?; //相当于（long？）obj 这里就没问题了，这样确保了在转型失败的情况下，null可以赋值给long?   A as B===》 B（A） B作为A

as的使用2：
Son son= new Son(18,"RJM");//子类
            
WriteLine((son as Father).age);//子类强转为父类
--------------------------------------------------------------------------------------------------------------------------------------------------------
10.
弱引用有什么作用：防止内存泄露。

怎样使用弱引用：

弱引用类： WeakReference   //有两个重载的构造函数

  WeakReference WeakObj=new WeakReference(Object);//弱引用方式 ----WeakObj弱引用Object类的对象

IsAlive属性是判断此弱引用对象所引用的对象是否还存在，存在：IsAlive=True;

Target属性是设置该弱引用对象所引用的数据对象的值


--------------------------------------------------------------------------------------------------------------------------------------------------------
10.释放非托管资源的（GC管不了的资源）的两种方式：

1.析构函数（又叫 终结器）：（自己主动调用不了的，GC自动调用的，即不稳定）
在 C# 中，析构函数用于释放被占用的系统资源。

使用析构函数时，应该注意下面的问题：
析构函数是以  “~” 开头的。
析构函数没有返回值，后紧跟类名，无参数。
构造函数只能在类中使用，而且只能有一个析构函数。
不能继承或重载析构函数。
不能在代码中去调用析构函数，它是在资源被销毁时由运行时库调用，同时会调用 Object 类的 Finalize 方法。通俗来讲就是，垃圾回收器决定了析构函数的调用，我们无法控制何时调用析构函数。

public class Myclass
{
    ~Myclass()//析构函数
    {
        //这是在finalize()方法执行之前，需要执行的代码，用于在该对象被回收前释放资源
    }
    
}

2.实现IDisposable接口（自己能主动调用的，即稳定） （Disposable：可任意处理的; 一次性的; 用后即丢弃的; 可动用的; 可自由支配的;）
public class Myclass : IDisposable
{
    public void Dispose()
    {
        //这是用于释放资源的代码
    }
}

关于Dispose()方法的使用：
一：

Myclass myclass = new Myclass();
//这里执行myclass在回收前执行的代码
myclass.Dispose();//手动调用Dispose()方法完成资源释放工作

二：
我们也可以把实现了IDisposable 接口的类的实例 写到一个 using 语句块中，当代码执行完成 using 语句块时会 自动调用 对象的 Dispose 方法，以释放占用的资源，

using(Myclass myclass=new Myclass()){//using的另一个使用地方
     //这里执行myclass在回收前执行的代码

     //最后自动调用myclass的Dispose()方法
}

这里的 using 语句和引入命名空间的 using 语句含义是不同的， 这里的 using 语句是限定一个范围，当代码执行到这个范围的结尾时会自动释放实现了 IDisposable 接口的对象实例。

--------------------------------------------------------------------------------------------------------------------------------------------------------
11.指针（只能写在unsafe代码块中）：
--------------------------------
&： 地址 即取变量所存数据的地址 

*： 值   即取得指针所指数据的值

例如：
int a = 1000; //变量 
int* b = &a;  //将变量的地址给指针 b=0x1234 int* 看作一个整体，表示指向整数的指针类型。
Write(*b);    //取得指针指向的内容
int c = (int)b;//b指针可以强转为整形，可能会有溢出
--------------------------------
指针的加减法：例如 对于指针int* a；  进行 a+1后 ，编译器就会 a的地址基础上向后移动 int型大小单位的距离（其他整形也是如此，只不过每次移动的单位大小不一样）。
--------------------------------
sizeof（基本类型）：基本类型占多少个字节  sizeof（long）==8
--------------------------------
fixed关键字：
引用类型属于托管资源，指针属于非托管资源
public class Myclass 
{
    public int a; //类中的变量
    public long b;//类中的变量
}
//错误写法：
static unsafe void Main(string[] args){//测试
        
       Myclass myclass = new Myclass();//对象

       int* p1 = &(myclass.a);	    

       long* p2 = &(myclass.b);	    //错误：指针引用了对象中的成员变量。如果GC回收了myclass，作为非托管资源的指针p1则会指向错误的地址。	

 }
//正确写法：
static unsafe void Main(string[] args){//测试
        
       Myclass myclass = new Myclass();//对象

       fixed ( int* p1 = &(myclass.a) )
       fixed ( long* p2 = &(myclass.b))//在fixed括号中 指针引用对象的成员变量
       { 
         //在当前代码块中，是p1和p2的作用域，p1和p2强制引用对象的属性，即被引用的对象myclass是不会被GC回收的
            
       };

}
--------------------------------------------------------------------------------------------------------------------------------------------------------
12.创建基于栈的数组(数组一般在堆中)：使用 stackalloc关键字。stackalloc后紧跟 数组的类型和大小，返回的是一个指向 栈上数组第一个位置的 指针。

static unsafe void Main(string[] args){

            int* p1 = stackalloc int[10];//创建一个在栈上的大小为10的数组，p1指向

            p1[5] = 10;			 //数组中元素的访问访问方式；下标

            *(p1 + 1) = 2;		 //数组中元素的访问访问方式；指针的加减运算

            WriteLine(p1[5]);

            Write(p1[1]);

           
}

--------------------------------------------------------------------------------------------------------------------------------------------------------
13.泛型的default关键字：

背景：在泛型类型中，由于泛型类型即可以是引用类型也可以是值类型，所以不能用null来表示默认值。这里通过default来进行。引用类型的default将泛型类型初始化null，值类型的default将泛型类型初始化为0。

public class Myclass<T>
{
    public T method(){

        T t = default(T);//T既能是值类型 也是引用类型，想要给t赋空值既不可能是0也不是null，只能是 default(T) 随机应变为 0或null赋空值。

        return t;
    
    }
}

static void Main(string[] args)
        {

            Myclass<int> myclass1 = new Myclass<int>();

            WriteLine(myclass1.Method());// 0

            Myclass<String> myclass2 = new Myclass<String>();

            WriteLine(myclass2.Method());// 什么也没有 缺省

        }

--------------------------------------------------------------------------------------------------------------------------------------------------------
14.泛型的约束（对T的类型有限制） 用到关键字 where 和 ：（：等价于extends）  用的时机： 在方法的定义时 对泛型进行约束，以限制传入的形参。

泛型约束一共有六种:约束的是字母T,程序中调用的T是什么类型,就要用什么样的类型
---------------------------------------------------------------
1.值类型,where:struct;

public class Myclass{//泛型类

    public void Method<T>(T t) where T:struct{ //核心方法Method。 所有的T都是 值类型的(因为继承于结构struct)

        WriteLine(t);
    }

}   
static void Main(string[] args){ //测试
        
        Myclass myclass = new Myclass();

        int a = 1;

        string s = new string("aaaa");

        myclass.Method<int>(a); //T为int，是值类型，编译通过

        myclass.Method<string> (s);//T为string，是引用类型，编译不通过


        }
---------------------------------------------------------------
2.引用类型,where：class    值类型声明的Object和Random在引用类型不会报错,因为约束的字母T就是要用引用类型填入

public class Myclass {

    public void Method<T>(T t) where T:class{ //核心方法Method。 所有的T都是 引用类型的(因为继承于类class)

        WriteLine(t);
    }

}

static  void Main(string[] args){//测试
     Myclass myclass = new Myclass();

     int a = 1;

     string s = new string("aaaa");

     myclass.Method<int>(a); //T为int，是值类型，编译不通过

     myclass.Method<string> (s);//T为string，是引用类型，编译通过

}
---------------------------------------------------------------  
3.存在无参公共构造函数,where:new()    举例来说：还是定义一个类 该类必须要有一个 无参的构造器
public class Myclass {

    public void Method<T>(T t) where T:new(){ //核心方法Method。 所有的T都是 有构造器的(因为继承于new（） 

        WriteLine(t);
    }

}

public class Test1                          //该类有无参构造器
{
    public Test1()
    {
    }
}

public class Test2                          //该类没有无参构造器
{
    public string name;

    public Test2(string name)
    {
        this.name = name;
    }
}

 static  void Main(string[] args){	    //测试
            Myclass myclass = new Myclass();

            Test1 test1 = new Test1();

            Test2 test2 = new Test2("xooos");

            myclass.Method<Test1>(test1); //编译通过

            myclass.Method<Test2>(test2); //编译器报错，类型必须是含公共无参构造器的类型
}

---------------------------------------------------------------
4.某个类本身或者其派生类,where:类名    T必须是某个类的子类      
----------------------------------------------------------------
5.某个接口的派生类型, where:接口名  只有传入的类实现了该接口，编译才能通过
---------------------------------------------------------------
6.另一个泛型类型本身或派生类型,where:另一个泛型字母   如： method<T> (T t) T:E  {    T必须是E的子类
						 }
-------------------------------------------------------------------------------------------------------------------------------------------------------- 
15.泛型类中的静态变量：

public class Myclass<T> {

    public static int a; //泛型类中的静态变量

}


static  void Main(string[] args){ //测试

            Myclass<int>.a = 1;       //泛型为ints

            Myclass<string>.a=2;      //泛型为string

                                      //Myclass<int>类和Myclass<string>类 是属于不同的类型，因此不冲突

            WriteLine(Myclass<int>.a);//1

            WriteLine(Myclass<string>.a);//2
}


-------------------------------------------------------------------------------------------------------------------------------------------------------- 
16.协变与逆变：类似于Java中的List<? extends/super String> 和 List<String>的关系。

核心：没有协变与逆变，List<object>和List<string>没有任何继承关系，相互独立；有了协变与逆变，List<object>和List<string>就有了继承关系，只不过继承方向不同。

定义：
协变：与原始类型转换方向相同的可变性称为协变。如果对于接口：List<out T>{}，A、B为实实在在的类型，有A<=B,则List<A> <= List<B>	  A为B的子集，则List<A>是List<B>的子集   对应out关键字

抗变：与派生类型转换方向相同的可变性称为抗变。如果对于接口：List<in  T>{}，A、B为实实在在的类型，有A<=B,则List<A> >= List<B>  A为B的子集，则List<B>是List<A>的子集  对应in关键字

协变定义：在 接口或者委托 中定义泛型时（类无法定义协变），加上out。定义方式：<out T>----在协变中，T只能作为方法的返回值，   不能作为参数

抗变定义：在 接口或者委托 中定义泛型时（类无法定义逆变），加上in。 定义方式：<in T>  ----在逆变中，T只能作为方法的参数，    不能作为返回值

在泛型接口中，如果类型参数满足以下条件，则可以声明为 协变（out）： 类型参数只用作接口方法的返回类型，而不用作方法参数的类型。反之则声明为抗变。

-------------------------------------------------------------------
没有协变与逆变：
public interface inter<T> { //没有协变与逆变，没有继承关系

    public void method(T t);
    
}

public class Test<T> : inter<T>{//继承类
    public void method(T t)
    {
        
    }  

}
public class Father { }		//父类
public class son: Father { }	//子类

static void Main(string[] args){
       inter<Father> father = new Test<Father>();

       inter<son> son = new Test<son>();

       father = son;//inter<Father>和inter<son> 没有任何关系，相互转化不了

       son = father;//inter<Father>和inter<son> 没有任何关系，相互转化不了
}
-------------------------------------------------------------------
协变：
public interface inter<out T> { //协变：out    A<=B,则List<A> <= List<B>
     public T method();
    
}

public class Test<T> : inter<T>{//继承类
    public T method()           //T只能作为返回值
    {
        return default(T);      
    }  

}
public class Father { }        //父类
public class son: Father { }   //子类


static void Main(string[] args){//测试
      inter<Father> father = new Test<Father>();

      inter<son> son = new Test<son>();

      father = son;	       //相同方向转化
}
-------------------------------------------------------------------
逆变：
public interface inter<in T> { //逆变 in A<=B,则List<A> >= List<B>

    public void method(T t);
    
}

public class Test<T> : inter<T>{//继承类
    public void method(T t)   //T只能作为方法的参数
    {
        
    }  

}
public class Father { }	      //父类
public class son: Father { }  //子类

static  void Main(string[] args){//测试

	//注意：father和son的静态参数必须是接口类型，才能用上逆变。
	inter<Father> father = new Test<Father>(); //父类作为泛型传入

        inter<son> son = new Test<son>();          //子类作为泛型传入

        son = father;				   //逆转过来，inter<son> 为父，inter<Father> 为子。
            
}


-------------------------------------------------------------------------------------------------------------------------------------------------------- 
17。泛型结构：类似于泛型类，只是没有继承。但还是结构。	
---------------------------------------------
典型的泛型结构：Nullable泛型结构。

public struct Nullable<T> where T:struct { //T有约束，只能是结构，即值类型。Nullable也是结构，值类型的。
}
---------------------------------------------
声明可空变量：

1：Nullable<int> a=1；

2：int？ b=1；

其中a和b类型一样，都为值类型。
---------------------------------------------
可空类型和不可空类型的转化：

不可空类型--->可空类型（有null）：自然转化，小范围到大范围  如： int a=1；  int？ b=a；

可空类型（有null）--->不可空类型：有可能转化失败，大范围到小范围

-------------------------------------------------------------------------------------------------------------------------------------------------------- 
18，泛型方法：
泛型方法的泛型类型 由方法自己声明，所以泛型方法可以定义在 非泛型方法中。
public class Myclass
{
    public T method<T>(T a) where T:struct //泛型方法且带泛型约束
    {
        return default(T);
    }

}

-------------------------------------------------------------------------------------------------------------------------------------------------------- 
19.数组：
---------------------------------------------------
数组的创建：
方式1.int[] array = new int[4];

  int[] array = new int[]{1,2,3,4};

  int[] array = 	 {1,2,3,4};
方式2.使用Array类的static方法----CreateInstance（数组元素的类型，数组的大小）

static void Main(string[] args){

        Array array = Array.CreateInstance(typeof(int), 5);//

        array.SetValue(100, 0);//设0位上的值为100

        object v = array.GetValue(0);

        Write(v);
}
---------------------------------------------------
数组的复制：
1.数组元素为值类型：
static void Main(string[] args){

            int[] array1 = new int[] { 1, 2, 3, 4 };

            int[] array2 = (int[])array1.Clone();	//Clone（）方法复制

            foreach(int i in array2)
            {
                Write(i);//1 2 3 4
            }

        }

2.数组元素为引用类型（Clone（）方法为浅拷贝）：
static void Main(string[] args){

            Myclass myclass = new Myclass();            //要放入数组的引用类型

            Myclass[] array1 = new Myclass[] { myclass};//数组1

            Myclass[] array2 = (Myclass[])array1.Clone();//复制数组1给2

            object v = array2.GetValue(0);		 //得到数组2的元素

            WriteLine(v == myclass);			 //True 相等	

        }
---------------------------------------------------
数组的排序：Array.Sort(实现了IComparable接口的数组) --- 实现了该接口就有了int CompareTo（）方法
static void Main(string[] args) {

            String[] array = { "java", "c","python" };//需要排序的数组

            Array.Sort(array);                        //排序

            foreach(String s in array)
            {

                Write(s);			      //排好序后： c   java  python
            }

}
---------------------------------------------------
数组支持协变：A<B,且F（A）<F(B)
static void Main(string[] args) {

            String[] array1 = { "java", "c","python" };


            object array2 = array1;		     //string是object子类,且 String[]也是object[]子类
}
---------------------------------------------------
数组片段：使用Arraysegment结构体 截取大数组的部分片段

Arraysegment结构体细节：

public readonly struct ArraySegment<T>{			//Arraysegment结构体

public ArraySegment(T[] array, int offset, int count) {}//构造器
		 被截取的数组  起始的下标   截取的长度
//核心的三个属性
public int Offset { get; }				//Offset:开端。被截取的数组的被截取开始部分的下标	
public T[]? Array { get; }				//ArraySegment结构体中的核心存储截取部分的数组。实际指向被截取的数组，并且能够访问没有被截取的部分。
public int Count { get; }				//被截取部分的长度


}
示例：
static void Main(string[] args) {

            int[] array1 = {1,2,3,4,5};      //要被截取的数组

            ArraySegment<int> arraySegment = new ArraySegment<int>(array1,3,2);//将数组截取一段，得到一个ArraySegment类型的片段。截取array1数组从下标3开始，长度为3的数组。

            arraySegment.Array[0] = 100;//改变截取数组的值，并直接能改变被截取的数组。通过结构体中的截取数组，并且不只是能改变截取部分。
            arraySegment.Array[1] = 200;
            arraySegment.Array[2] = 300;
            arraySegment.Array[3] = 400;
            arraySegment.Array[4] = 500;

            foreach(int i in array1)    //打印原数组，居然全被改变了
            {
                WriteLine(i);		//100 200 300 400 500
            }
            
            WriteLine("---------------------");

            WriteLine(arraySegment.Offset);//3
            WriteLine(arraySegment.Count);//2
}

-------------------------------------------------------------------------------------------------------------------------------------------------------- 
20.迭代器（枚举）：不直接遍历容器，而是通过其对于的迭代器遍历。（IEnumerable是可枚举的意思； IEnumerator是枚举器的意思，相当于Java中的迭代器；都是接口）

核心：IEnumerator接口的作用才是迭代的主体，通过需要遍历的集合获取其元素的映射，所以遍历迭代器就是遍历集合；  而IEnumerable接口的作用就是 让其实现类实现GetEnumerator()方法，从而获得枚举器IEnumerator 

IEnumerable接口：
public interface IEnumerable{
	IEnumerator GetEnumerator()；//实现了IEnumerable接口，就相当于拥有了 迭代器。
}

IEnumerator接口：
public interface IEnumerator{

	object Current{get；}	//Current属性指向迭代器中 当前元素

	bool MoveNext（）；	//MoveNext（）方法用于移动到下一个元素

	void Reset（）；		//Reset方法重置
}

示例：
static void Main(string[] args) {

           int[] array = new int[5] {1,2,3,4,5};  	//实现了IEnumerable接口的容器，拥有了迭代器

           IEnumerator iterator=array.GetEnumerator();  //得到对于的迭代器

           while (iterator.MoveNext()){   
                
		WriteLine(iterator.Current);		//迭代器的核心方法用于遍历迭代器
                
            }

}

-------------------------------------------------------------------------------------------------------------------------------------------------------- 
21.yield 语句： yield关键字向 编译器指示它所在的方法 是 迭代器块。

1.yield return 返回值：在yield return语句中，将返回值返回给集合()---该集合的名字就是以yield语句所在方法的方法名。粗略地说，yield return返回的是一个可迭代的集合。

即向枚举器对象提供值。这是一个返回值，例如，在 foreach 语句的每一次循环中返回的值。

2.yield break：表示迭代结束。配合yield return使用，当产生集合达到某种条件的时候使用yield break，以终止继续创建集合

---------------------------------------------
示例1： 平常循环返回集合的使用操作。
static List<int> GetList()
        {
            List<int> list = new List<int>();//先得造一个集合

            for (int i = 0; i < 10; i++)     //向集合中加入元素
            {
                list.Add(i);                 
            }
            return list;                     //返回一个集合
        }
static void Main(string[] args) {//测试

	    IEnumerable<int> getList = Program.GetList();//获取getList集合

	    foreach ( int i in getList)//遍历容器类

            Console.WriteLine(i);      //0 1 2 3 4 5 6 7 8 9 
            
        }
---------------------------------------------
示例2： 有yield return后。

static IEnumerable<int> GetList(){ //GetList()方法返回的是一个 实现了IEnumerable接口(即可迭代) 的集合（名字为GetList）。

            for (int i = 0; i < 10; i++)
            {
                yield return i;	   //yield return是"语法糖"（有了它，更简单），其本质是生成了一个GetList的实例，然后yield return是一个一个向GetList集合中加入元素。	
            }		           //yield return返回的集合之所以能被迭代、遍历，是因为GetList内部有迭代器
        }			   //yield return之所以能实现"按需供给"，是因为GetList内部有一个_state字段记录这上次的状态


static void Main(string[] args) {//测试

	IEnumerable<int> getList = Program.GetList();//获取GetList集合

	foreach ( int i in getList)//遍历容器类

        Console.WriteLine(i);      //0 1 2 3 4 5 6 7 8 9 
            
        }
---------------------------------------------
示例3： 有yield yield break后。
static IEnumerable<int> GetList()
        {
	    int i = 0;
            while (true)
            {
                if (i >= 7)
                {
                    yield break;//如果指向到yield break，yield return就不会向集合中添加元素了
                }
                yield return i;
                i++;

            }		           
        }   
static void Main(string[] args){//测试

            IEnumerable<int> getList = Program.GetList();

            foreach (int i in getList)

            Console.WriteLine(i);//0 1 2 3 4 5 6      
}

-------------------------------------------------------------------------------------------------------------------------------------------------------- 
22.数组存放着 相同类型的对象，而元组放着 不相同类型的对象。Tuple：元组。

作用：元组就是一些对象的集合，在我们编程时，比如一个人的信息，我们常常创建一个Person类去描述一个人，使用元组后最大的用处就是，不用为了 一些简单的结构或对象而去新建一个类了。

    元组是可以存贮多种类型的对象，可以想象一下当一个函数拥有多个不同类型的返回值时，我们除了定义了一个返回值以外，还要定义多个out或ref类型返回值才能解决这个需求；

    当然我们也可以定义一个对象保存多个返回值。但现在我们多了一个解决方案，定义返回值为一个元组，就解决了一切。

范围：支持具有 1 到 7 元素的元组。 此外，您可以创建由嵌套中的元组对象的元组的八个或多个元素Rest属性Tuple<T1, T2, T3, T4, T5, T6, T7, TRest>对象。

.NET Framework 定义了 8个泛型 Tuple 类和一个静态的 Tuple类， 他们用作元组的工厂。 不同的泛型 Tuple 类支持不同数量的元素。 

例如 Tuple<T1> 包含一个T1类的元素， Tuple<T1,T2>包含两个T1类和T2类元素，以此类推。

static void Main(string[] args){//测试

            Tuple<string, int, double> tuple = new Tuple<string, int, double>("xooos",18,3.14);//创建元组

            WriteLine(tuple.Item1);//取得元组中的元素
            WriteLine(tuple.Item2);
            WriteLine(tuple.Item3);
}


-------------------------------------------------------------------------------------------------------------------------------------------------------- 
23.C#运算符：
--------------------------------------------
checked：   checked代码块包括的代码，编译器需要对其进行算术符溢出的检测。

unchecked： 编译器一般是unchecked的。

static void Main(string[] args){//测试

            byte b = 255;

            checked {
                b++;           //报算术符溢出异常
            }
            
	    Write(b);
}

static void Main(string[] args){//测试

            byte b = 255;

            b++;

            Write(b);//0
 }
--------------------------------------------
typeof运算符：
static void Main(string[] args){//测试

            Type type = typeof(string);//返回string的Type对象。

            Write(type);	       //System.String
            
}
--------------------------------------------
空值传播运算符： 《C# 本质论》中翻译为null条件操作符。就是个 ？ 号 。

背景：在调用值为null的方法时，运行时都会抛出一个System.NullReferenceException的异常，通常以此表明程序逻辑上存在错误。考虑到在调用成员之前进行null值检查这一模式的频率很高，

    C# 6.0 引入了一种更为简化的null条件操作符 ?  。

用法：null条件操作符在调用方法或属性之前检查操作数是否为null，如果为null，则不执行？后面的代码；如果不为null，则执行？后面的代码。

static void Main(string[] args){//测试

            Myclass myclass = null;

            if (myclass == null) return; //原来需要对对象进行判断是否为空

            myclass.method() ;
}

static void Main(string[] args){//测试

            Myclass myclass = new Myclass();

            myclass?.method() ;     //空值传播运算符的使用，如果myclass 为空就不调用，不为空就调用。


        }

特别地；空值传播运算符和合并运算符的结合：
static void Main(string[] args){//测试

	    //int?[] arr = null;
	    //int?[] arr = new int?[] { 1, null, 3 }; ;	
            int?[] arr = new int?[] { 1, 2, 3 }; 

            int a = arr?[1] ?? 0;//经过两次非空检查，一是对arr；二是对arr[1]。

            Write(a);
        }
-------------------------------------------------------------------------------------------------------------------------------------------------------- 
24.比较对象的相等性

-----------------------------------
引用类型：

1.ReferenceEquals（实例1，实例2）方法；静态方法。

static void Main(string[] args){//测试

            Myclass myclass1 = new Myclass();

            Myclass myclass2 = new Myclass();

            WriteLine(ReferenceEquals(myclass1, myclass2));//false

            myclass2 = myclass1;

            WriteLine(ReferenceEquals(myclass1, myclass2));//ture
        }



2.实例Equals（）方法，需要每个类重写。


3.静态Equals（）方法。
static void Main(string[] args){//测试

            Myclass myclass1 = new Myclass();

            Myclass myclass2 = new Myclass();

            WriteLine(Equals(myclass1, myclass2));//false

            myclass2 = myclass1;

            WriteLine(Equals(myclass1, myclass2));//ture
        }

-----------------------------------
值类型：Equals()方法比较。

static void Main(string[] args){//测试

           WriteLine(100.Equals(200));//false

           WriteLine(100.Equals(100));//ture
}

-------------------------------------------------------------------------------------------------------------------------------------------------------- 
25.运算符的重载：简单来说就是让自己自定义的对象 也能进行加减乘除运行。
-----------------------------------
+, -, !, ~, ++, --				这些一元运算符只有一个操作数，且可以被重载。
+, -, *, /, %	        			这些二元运算符带有两个操作数，且可以被重载。
==, !=, <, >, <=, >=				这些比较运算符可以被重载。
--------------
&&, ||	                			这些条件逻辑运算符不能被直接重载。
+=, -=, *=, /=, %=				这些赋值运算符不能被重载。
=, ., ?:, ->, new, is, sizeof, typeof		这些运算符不能被重载。
-----------------------------------
例如：对Box类
class Box
{   
    private double length;      // 长度
    private double breadth;     // 宽度
    private double height;      // 高度

    public Box(double length, double breadth, double height)
    {
        this.length = length;
        this.breadth = breadth;
        this.height = height;
    }
    public double getVolume()
    {
        return length * breadth * height;
    }
    

    public double Length { get; }
    public double Breadth { get; }
    public double Height { get; }


    public static Box operator +(Box box1,Box box2) {


        return new Box(box1.length + box2.length, box1.breadth + box2.breadth, box1.height + box2.height);
            
    }
    public static bool operator <=(Box box1, Box box2)
    {
        bool status = false;
        if (box1.length <= box2.length && box1.height
            <= box2.height && box1.breadth <= box2.breadth)
        {
            status = true;
        }
        return status;
    }
    public static bool operator >=(Box box1, Box box2)
    {
        bool status = false;
        if (box1.length >= box2.length && box1.height
           >= box2.height && box1.breadth >= box2.breadth)
        {
            status = true;
        }
        return status;
    }
}


static void Main(string[] args){       //测试

            Box box1 = new Box(1, 2, 3);

            Box box2 = new Box(4, 5, 6);

            Box box3 = box1 + box2;    //加法

            WriteLine(box3.getVolume());//315

            WriteLine(box1<=box2);//true  小于
}

-------------------------------------------------------------------------------------------------------------------------------------------------------- 
26.自定义索引器----索引器是一种特殊的类成员，它能够让 对象 以类似数组的方式来存取，使程序看起来更为直观，更容易编写。 如:对象1[10]

索引器的定义: 核心---想要操作某个类中的数组或集合时，利用索引器间接的对 类中的容器进行操作。

   C#中的类成员可以是任意类型，包括数组和集合。当一个类包含了数组和集合时，我们想要数组和集合进行操作时，用索引器将大大简化对数组或集合成员的存取操作。其一般形式如下：
------------------------------------------------------------------------
[修饰符]        数据类型               this[索引类型 index]
	 集合或数组里面元素的类型   当前对象[定位的方式，整数或字符串等]
{

    get{//获得属性的代码}                                                 

    set{ //设置属性的代码}

}
数据类型   是表示将要存取的数组或集合元素的类型。

this      表示操作本对象的数组或集合成员，可以简单把它理解成索引器的名字，因此索引器不能具有用户定义的名称。 

索引器类型 表示该索引器使用哪一类型的索引来存取数组或集合元素，可以是整数，可以是字符串。
------------------------------------------------------------------------
例：
class Myclass{

    private string[] array = new string[100];//需要操作的数组

    public string this[int i]   //自定义索引器，
    {
        get { return array[i];}

        set { array[i] = value; }
    }
}

static void Main(string[] args){//测试

            Myclass myclass = new Myclass();

            myclass[10] = "xooos";  //对象[10]--使用了自定义索引器

            WriteLine(myclass[10]);
}     
--------------------------------------------------------------------------------------------------------------------------------------------------------
27.委托
核心：delegate关键字定义好一个 委托类 后，这个委托类就代表着 返回值和形参相同的一类方法。当委托类确定好被委托的方法簇后，委托类的实例就保存了方法簇中各个方法的地址，

    就可以用委托类的实例去调用这些方法簇。

定义一个委托类：  delegate 方法的返回值类型 委托类名(方法的形参列表);----->与抽象方法相似，代表着一类相似的方法。

delegate void Mydelegate (int x); //定义一个委托类型

        static void Method1(int y)        //被委托的方法1
        {
            WriteLine("Method1 "+ y);
        }

        static void Method2(int y)        //被委托的方法2
        {
            WriteLine("Method2 "+y);
        }
        
        public static void Main(string[] args)//测试
        {

            Mydelegate cr = Method1;  			创建委托类的实例 方式1：

 	    //Mydelegate cr = new Mydelegate(Method1);  创建委托类的实例 方式2：

            cr = cr + Method2;
	    
	    cr.Invoke(1000);//调用委托方法 方式1：

            cr(1000);       //调用委托方法 方式2：

	    //Method1 1000
	      Method2 1000
        }
	
	

    }
-----------------------------------------------------------------
Action和Func委托类：Action与Func是微软为我们预先定义好了的，两个委托变量。其中Action是不带返回值的委托，Func是带返回值的委托。


		可以说，Action与Func完全包含了，我们日常使用所需的，全部的，委托变量。


		也就是说，我们可以不用再去自己手动声明委托了。

public delegate void Action<in T1, in T2>(T1 arg1, T2 arg2);

public delegate TResult Func<in T, out TResult>(T arg)

-------------------------------------------------
static void Method1(int y){        //被委托的方法1：Action是不带返回值的委托
        
            WriteLine("Method1 "+ y);
        }

public static void Main(string[] args){//测试
        
            Action<int> action = Method1;

            action(1000) ;
         }
----------------------------
static string Method2(int y){        //被委托的方法2：Func是带返回值的委托
        
		return "Method2 " + y;
        }

public static void Main(string[] args){//测试
        
            Func<int,string> action = Method2;

            Write(action(1000));
} 

-------------------------------------------------------------------
多播委托：如果要调用多个方法，可以使用一个委托来完成。也就是委托可以包含多个方法。即一个委托实例不仅可以指向一个方法，还可以指向多个方法。

注意：多播委托的所有方法返回值必须为void，否则调用该委托时，返回的值不知道时其对应的多个方法的哪一个。

例子：
delegate void Mydelegate (int x); //定义一个委托类型

        static void Method1(int y)        //被委托的方法1
        {
            WriteLine("Method1 "+ y);
        }

        static void Method2(int y)        //被委托的方法2
        {

            WriteLine("Method2 " + y);
        }
        
        public static void Main(string[] args){//测试
        
            Mydelegate mydelegate = Method1;

            mydelegate = mydelegate + Method2;//委托了两个方法，且返回值为void

            mydelegate(100);//Method1 100
                            //Method2 100
}
-------------------------------------------------------------------
匿名方法：在实例化委托类时使用的结构。

背景：每一次实例化一个委托类时，都需要事先定义好一个方法。为了简化代码，可以使用匿名方法。

语法：  委托类 委托名= delegte (方法的形参){方法体}

      》》》  delegte (方法的形参){方法体} 《《《  注意：整体等价于一个方法，所以需要被 委托类委托。


delegate void Mydelegate (int x); //定义一个委托类型

public static void Main(string[] args){//测试

        Func<string,string> func= delegate(string s){//使用现有的Func委托类去接受 一个匿名的方法
                    
                 return s;
        };

        Mydelegate mydelegate=    delegate (int a) { //使用自定义的委托类去接受 一个匿名的方法

                Write("xooos " + a);

        };

        WriteLine(func("xooos"));

        mydelegate(1000);
            
} 
-------------------------------------------------------------------
Lambda表达式：基于匿名方法

背景：江山代有才人出，纵然匿名方法使用很方便，可惜她很快就成了过气网红，没能领多长时间的风骚。如今已经很少见到了，因为delegate关键字限制了她用途的扩展。

    自从C# 3.0开始，她就被Lambda表达式取代，而且Lambda表达式用起来更简单。Lambda表达式本质上 是改进的匿名方法。 

定义：在匿名方法的基础上去掉了	delegate关键字--- 委托类 委托名= （形参列表）  => {方法体}；
示例：
delegate void Mydelegate (int x); //定义一个委托类型

public static void Main(string[] args){//测试

       Func<string,string> func1=delegate(string s){//匿名方法的方式实例化委托
                    
                 return s;
             
       };

       Func<string, string> func2 = (string s) => { return s; };//Lambda表达式的方式实例化委托

       Mydelegate mydelegate1= delegate (int a) {//匿名方法的方式实例化委托

                 Write("xooos " + a);

       };

       Mydelegate mydelegate2 = (int a) => { Write("xooos " + a); };//Lambda表达式的方式实例化委托

       WriteLine(func1("xooos1"));

       WriteLine(func1("xooos2"));

       mydelegate1(1000);

       mydelegate1(2000);
}

-------------------------------------------------------------------
事件：有访问限制的委托实例。 

定义：先有一个委托类型 ----> Event 委托类型 事件名+=被委托的方法(观察者的方法)    其中Event关键字 可以理解为将委托实例的访问权限强制改为private

委托总结：

      优点：委托可以作为方法的一个参数来传递。谁要调用Computer里的DoWork来完成自己的事情，谁就实现委托绑定的方法，这样就可以按照自己的需求传递不同的方法，使程序具有了很好的扩展性。

      缺点：我们可以随意的给委托进行赋值，这样就破坏了程序的封装性。

      为了弥补委托的缺陷，所以事件出现了，我们只能对事件进行“+=”和“-=”操作，不可以对事件进行赋值（=）操作。注意：事件就是更安全的委托示例

例子背景：假设我们有个高档的热水器，我们给它通上电，当水温超过95度的时候：1、扬声器会开始发出语音，告诉你水的温度；2、液晶屏也会改变水温的显示，来提示水已经快烧开了。

       其中 观察者为扬声器和液晶屏 ； 被观察者为热水器。https://www.jb51.net/article/32415.htm
----------------------------
示例1:
delegate void Mydelegate (int x); 		//定义一个委托类型

            public class Heater{                //热水器
            
                private int temperature;        //热水器的温度

                public delegate void Mydelegate(int param);//声明委托

                public event Mydelegate BoilEvent;         //根据委托声明事件实例

                
                public void BoilWater(){// 烧水

                for (int i = 0; i <= 100; i++)
                    {
                        temperature = i;

                        if (temperature > 95)
                        {
                            if (BoilEvent != null){       //如果有观察者

                               BoilEvent(temperature);    //相当于触发了事件，就调用所有观察者的方法
                            }
                        }
                    }
                }
            }

            public class Alarm// 警报器
        {
                public void MakeAlert(int param)
                {
                    Console.WriteLine("Alarm：嘀嘀嘀，水已经 {0} 度了："+ param);
                }
            }

            
            public class Display // 显示器
        {
                public static void ShowMsg(int param)
                {
                    Console.WriteLine("Display：水快烧开了，当前温度：{0}度。"+ param);
                }
            }



        public static void Main(string[] args){//测试
                Alarm alarm = new Alarm();	    // 有一个警报器

                Display display = new Display();    // 有一个显示器

                Heater heater = new Heater();       //有一个热水器

                heater.BoilEvent += alarm.MakeAlert;//观察者向被观察者注册

                heater.BoilEvent += Display.ShowMsg;//观察者向被观察者注册

                heater.BoilWater();                 //热水器烧水
        }
----------------------------
Observer设计模式中主要包括如下两类对象：
1.Subject：监视对象，它往往包含着其他对象所感兴趣的内容。在本范例中，热水器就是一个监视对象，它包含的其他对象所感兴趣的内容，就是temprature字段，

当这个字段的值快到100时，会不断把数据发给监视它的对象。

2.Observer：监视者，它监视Subject，当Subject中的某件事发生的时候，会告知Observer，而Observer则会采取相应的行动。在本范例中，

Observer有警报器和显示器，它们采取的行动分别是发出警报和显示水温。

对示例1的改进 示例2：
// 热水器
        public class Heater
        {
            private int temperature;
            public string type = "RealFire 001";    // 添加型号作为演示
            public string area = "China Xian";     // 添加产地作为演示
                                                   //声明委托
            public delegate void BoiledEventHandler(Object sender, BoiledEventArgs e);
            public event BoiledEventHandler Boiled; //声明事件

            // 定义BoiledEventArgs类，传递给Observer所感兴趣的信息
            public class BoiledEventArgs : EventArgs
            {
                public readonly int temperature;
                public BoiledEventArgs(int temperature)
                {
                    this.temperature = temperature;
                }
            }

            // 可以供继承自 Heater 的类重写，以便继承类拒绝其他对象对它的监视
            protected virtual void OnBoiled(BoiledEventArgs e)
            {
                if (Boiled != null)
                { // 如果有对象注册
                    Boiled(this, e); // 调用所有注册对象的方法
                }
            }

            // 烧水。
            public void BoilWater()
            {
                for (int i = 0; i <= 100; i++)
                {
                    temperature = i;
                    if (temperature > 95)
                    {
                        //建立BoiledEventArgs 对象。
                        BoiledEventArgs e = new BoiledEventArgs(temperature);
                        OnBoiled(e); // 调用 OnBolied方法
                    }
                }
            }
        }

        // 警报器
        public class Alarm
        {
            public void MakeAlert(Object sender, Heater.BoiledEventArgs e)
            {
                Heater heater = (Heater)sender;   //这里是不是很熟悉呢？
                                                  //访问 sender 中的公共字段
                Console.WriteLine("Alarm：{0} - {1}: ", heater.area, heater.type);
                Console.WriteLine("Alarm: 嘀嘀嘀，水已经 {0} 度了：", e.temperature);
                Console.WriteLine();
            }
        }

        // 显示器
        public class Display
        {
            public static void ShowMsg(Object sender, Heater.BoiledEventArgs e)
            {  //静态方法
                Heater heater = (Heater)sender;
                Console.WriteLine("Display：{0} - {1}: ", heater.area, heater.type);
                Console.WriteLine("Display：水快烧开了，当前温度：{0}度。", e.temperature);
                Console.WriteLine();
            }
        }

        class Program
        {
            static void Main()
            {
                Heater heater = new Heater();
                Alarm alarm = new Alarm();

                heater.Boiled += alarm.MakeAlert;  //注册方法
                heater.Boiled += (new Alarm()).MakeAlert;   //给匿名对象注册方法
                heater.Boiled += new Heater.BoiledEventHandler(alarm.MakeAlert);  //也可以这么注册
                heater.Boiled += Display.ShowMsg;    //注册静态方法

                heater.BoilWater();  //烧水，会自动调用注册过对象的方法
            }
        }
--------------------------------------------------------------------------------------------------------------------------------------------------------
28.正则表达式：

元字符(某一个字符的范围)：

	\d  一个数字 0-9                                    \D:非\d

	\w  一个单词 0-9 a-z A-Z	_	           	   \W:非\w

	\s  一个空格或TAB或换行				   \S:非\s						

	·   任意一个字符（没有换行）  = \w + \s

转义字符；  如：在 123^abc456def 中查找 ^ ;由于 ^是元字符 ， 必须使用 \^ 才能匹配到 123^abc456def 中的 ^。
 
重复次数符号：   * ： *前面 一个字符 重复次数>=0次    如： a*       等价于   空位 a aa aaa .....

              + ： +前面 一个字符 重复次数>=1次    如： ra+t     等价于   a aa aaa .....

              ？ ：？前面 一个字符 出现0或1次       如： ra?t     等价于  空位 a

	      {n}：只重复n次                    如：(an){2}   等价于  anan

              {n,m}:重复次数在n到m之间          如：(an){2，3} 等价于  anan 或 ananan

(多个字符)：表示多个字符是一个整体。如 (an) 中 an是一个整体；则 (an)+ 等价于 an anan ananan等 

自定义范围： [想要包括的范围]   如：[\d a-z A-Z _] 等价于 \w 。 注意：自定义范围只是表示 一个字符 的范围。  

--------------------------------------------------------------------------------------------------------------------------------------------------------
29.集合

1.列表：list<T>

public static void Main(string[] args){//测试

            List<int> list1 = new List<int>() { 1, 2, 3 };//列表1

            list1.Add(4);//添加元素

            list1.Insert(0, 0);//在某个位置上插入元素

            list1.RemoveAt(0);//删除某个位置上的元素

            WriteLine(list1.IndexOf(3));//IndexOf() 返回某个元素的位置

            for (int i = 0; i < list1.Count; i++)
            {
                WriteLine(list1[i]);//支持索引器，即[]查找
            }

            WriteLine("-------------------------------------");

            List<int> list2 = new List<int>() { 34, 56, 89,99,1000};//列表2

            list2.Sort();//排序

            for (int i = 0; i < list2.Count; i++)
            {
                WriteLine(list2[i]);//支持索引器，即[]查找
            }
}
------------------------------------------------
2.队列 Queue<T>
public static void Main(string[] args){//测试

            Queue<int> queue = new Queue<int>();//创建一个队列

            queue.Enqueue(5);
            queue.Enqueue(4);
            queue.Enqueue(3);
            queue.Enqueue(2);
            queue.Enqueue(1);                   //元素入队

            WriteLine(queue.Count);//5          //统计队列中元素个数

            WriteLine(queue.Peek());//5         //只读取队头元素，而不删除

            WriteLine(queue.Dequeue());//5      //  读取队头元素，并且删除

            WriteLine(queue.Count);//4          //统计队列中元素个数
}
------------------------------------------------
3.栈 Stack<T>	

API:  Count():返回栈中的元素个数

      Push() :元素入栈

      Pop()  :删除栈顶元素，并返回该值

      Peek() :返回栈顶元素，但不删除
	
      Contains(): 确定某个元素是否在栈中

------------------------------------------------
4.链表 Linklist<T>

API:    构造器：Linklist<T>(Collection 集合)；一般常用

	Find(节点的值) ：       根据节点值返回整个节点
       
        AddAfter(整个节点，值)： 在指定节点后添加一个新节点

	AddBefore(整个节点，值)：在指定节点前添加一个新节点

        Remove(值)：           删除该值的整个节点

public static void Main(string[] args){//测试

            List<int> list = new List<int>() { 10, 20, 30, 40, 50, 60 };

            LinkedList<int> linkedList = new LinkedList<int>(list) ;//用集合创建链表

            WriteLine(linkedList.Count);//6

            WriteLine(linkedList.First.Value);//10 First指向链表的第一个元素
            
            WriteLine(linkedList.Last.Value);//60  last指向链表的最后一个元素

            WriteLine(linkedList.Find(40).Value);//40 Find(节点的值) ：根据节点值返回整个节点
            

            linkedList.AddAfter(linkedList.Find(60), 7);//添加一个节点

            WriteLine(linkedList.Last.Value);
}
------------------------------------------------
5.有序列表： SortedList<T, V> 存储KeyValuePair<T, V>类型的键值对。SortedList会自动对其数据进行 按键的值 进行排序。

示例：
public static void Main(string[] args){//测试

            SortedList<int, string> sortedList = new SortedList<int, string>();

            sortedList.Add(30,"so1");
            sortedList.Add(50,"so2");
            sortedList.Add(10,"so3");
            sortedList.Add(20,"so4");

            foreach(KeyValuePair<int,string> k in sortedList){ //遍历

                Write(k.Key+"  ");

                WriteLine(k.Value);
				  //10  so3
				    20  so4
				    30  so1
				    50  so2
            }
}

------------------------------------------------
6.字典(就是Map，存储键值对)底层哈希表：Dictionary<T,R>存储的是KeyValuePair<T,R>键值对。

public static void Main(string[] args){//测试

            Dictionary<int, string> dictionary = new Dictionary<int, string>() //特别的初始化格式：  [键] = 值 。
            {

                [1] = "so1",         

                [2] = "so2",

                [3] = "so3"
            };

            foreach(KeyValuePair<int , string> kv in dictionary){   //遍历

                Write(kv.Key + "  ");

                WriteLine(kv.Value);
            }

------------------------------------------------
7.Lookup<TKey, TElement>类：字典是存储键值对KeyValuePair<T,R>，一个键对应一个值 ；Lookup类中的也是键值对IGrouping<TKey, TElement>，只不过一个键对应多个值，有sql语句 group by 的分组作用。

Lookup类的创建：必须要求 集合的ToLookup( F（X）)方法 。F（X）是一个 有参数，有返回值的方法簇的委托，该方法的返回值作为为Lookup类的分类标准。


public static void Main(string[] args){//测试

            List<Myclass> list =new List<Myclass>();

            list.Add(new Myclass("xooos1", 1, "so1"));
            list.Add(new Myclass("xooos2", 2, "so2"));
            list.Add(new Myclass("xooos2", 3, "so3"));
            list.Add(new Myclass("xooos3", 4, "so4"));
            list.Add(new Myclass("xooos3", 5, "so5"));
            list.Add(new Myclass("xooos4", 6, "so6"));
            list.Add(new Myclass("xooos5", 7, "so7"));

            //lookups的单位：IGrouping<TKey, TElement>
            Lookup<string, Myclass> lookups = (Lookup<string, Myclass>)list.ToLookup( myclass =>myclass.name );//以name作为分类标准，lookup类中只有5个不同的名字
													       //lookup中 一个字符串 对应多个Myclass对象
													       //      即 一个键     对应多个值
            foreach(IGrouping<string,Myclass> ig in lookups)//查看
            {
                foreach(Myclass mc in ig)
                {
                    WriteLine(mc.desc);
                }
               
            }
            
        }
------------------------------------------------
8.集 Iset
--------------------------------------------------------------------------------------------------------------------------------------------------------
30.特殊的集合
--------------------------------------------------------
处理位的集合：

1.BitArray类： 是一个容器，存储的是true或false的序列，即每一位都是true或false(0或1也行)。 用于事先不知道位数。

  构造器： new Bitarray(整数):         构建一个整数大小的全是false的序列。

         new Bitarray(整数，Boolean): 构建一个整数大小的全是指定Boolean的序列。

	 new Bitarray(Bytes[])    :  将Bytes[]数组的各个元素转化为0或1连接起来作为一个序列。

         new Bitarray(Boolean[])  ：  直接将Boolean[]的每个元素当作序列的0或1。
         
  	 
 public static void Main(string[] args){//测试

            bool[] bytes = { true, false, false, true };

            BitArray bitArray = new BitArray(bytes);//处理位容器

            foreach(bool b in bitArray)
            {
                WriteLine(b?1:0);    //1 0 0 1
            }
	    
	    WriteLine(bitArray[1]);  //false       支持索引器，即[]查找。
}

2.BitVector32结构体：是一个容器，存储的是true或false的序列，即每一位都是true或false(0或1也行)。但是长度只为 32位 或 32的整数倍位。
  
  构造器：new BitVector32(整数)；  构建一个32位长，整数对应的二进制流的序列。

 public static void Main(string[] args){//测试

            BitVector32 bitVector32 = new BitVector32(2);

            WriteLine(bitVector32);      //BitVector32{00000000 00000000 00000000 00000010}

            WriteLine(bitVector32[2]);   //支持索引器，true

            WriteLine(bitVector32.Data); //获取存储的整数2

        }
--------------------------------------------------------
可观察的集合：？
--------------------------------------------------------
不可变的集合： Immutable 不可变的 

    每一个集合都有其对应的 不可变集合：如

    ImmutableArray<T> 不可变数组；ImmutableStack<T> ImmutableQueue<T> ImmutableList<T> 不可变列表； ImmutableHashSet<T> ImmutableSortedSet<T> ImmutableDictionary<K, V>

静态方法：
public static void Main(string[] args){//测试

            ImmutableArray<string> immutableArray1 = ImmutableArray.Create<string>(); /ImmutableArray类的Create()方法创建了一个mmutableArray结构体
	     
            ImmutableArray<string> immutableArray2 = immutableArray.Add("xooos1").Add("xooos2").Add("xooos3");//Add()只能返回一个新的不可变数组。

            foreach (String s in immutableArray2)
            {
                WriteLine(s);
            }
}

实例方法：
public static void Main(string[] args){//测试

            int[] array = new int[] {1,2,3,4};                                               //数组

            ImmutableArray<int> immutableArray = array.ToImmutableArray();                   //数组转变为 不可变数组 内容不变

            List<string> list = new List<string>() {"xooos1", "xooos2", "xooos3", "xooos4",};//List集合

            ImmutableList<string> immutableList = list.ToImmutableList<string>();            //List集合转变为 不可变List集合 内容不变

            foreach (int i in immutableArray)
            {
                WriteLine(i);//1 2 3 4
            }

            foreach(string s in immutableList)
            {
                    WriteLine(s);//"xooos1"  "xooos2"  "xooos3" "xooos4"
            }

        }

    注意：生成后的 不可变集合会有很多操作本集合的方法；增删操作会生成一个新的 不可变集合。
--------------------------------------------------------
并发集合：？
--------------------------------------------------------------------------------------------------------------------------------------------------------
31.LINQ(Language Integrated Query) 语言集成查询    注意：查询表达式必须以from开始 并以select子句或group子句结束。中间使用其他语句。

   总结：where select orderby 三个都返回的是 原集合的某个子集 ；group by返回的是键值对
   
   前提：创建匿名对象。

   public static void Main(string[] args){//测试 
            var NoName = new { name = "xooos", age = 18 };

            WriteLine(NoName.name);

            WriteLine(NoName.age);
        }
--------------------------------------------------------
1）from子句：from子句指定了要作为数据源使用的数据集合。 (核心：from确定集合)
	
          使用方法： from 数据类型 迭代变量 in 要查询的数据源   即from 单个元素类型 变量 in 集合

          说明：

          ① 迭代变量 有序表示数据源的每一个元素；

          ② 数据类型  是集合中元素的类型，数据类型是可选的，因为编译器会从集合来自动推断出迭代变量的类型；

          ③ 要查询的集合 必须是可以枚举的。


2）where子句：where子句根据之后的运算来去除不符合指定条件的项。(核心：where选出符合条件的集合元素)
 
          语法：  where 布尔表达式             where子句将布尔表达式，应用于由迭代变量引用的每个源元素，并返回满足指定条件的元素。
	
          使用where子句需注意以下几点：

	 （1）where子句是一种筛选机制，它不能是查询表达式中的第一个或最后一个子句；

	 （2）如果where子句中设定的布尔表达式对当前数据源的元素无效，则会发生编译错误；

	 （3）编译时，where关键字会被转换为where标准查询运算符方法的调用。

3）select子句： 对象本身或对象的部分应该被选择。它可以指定下面的任意一项：

	     （1）整个数据项

	     （2）数据项的一个字段

	     （3 重要）数据项中的几个字段 组成的新对象 --->相当于sql查询中select语句选中了需要显示的字段，只不过C#还必须需要将这几个属性组合成一个新的对象才能显示。

	     定义： select 单个对象引用变量或其部分属性

	     select子句的结果 基于前面所有子句的计算结果以及select子句本身的所有表达式。

public static void Main(string[] args){//测试

            Myclass[] array = new Myclass[] {new Myclass("xooos1",1,"desc1"), new Myclass("xooos2", 2, "desc2"), 
                              new Myclass("xooos2",3, "desc3"), new Myclass("xooos3",4, "desc4"), new Myclass("xooos3",4, "desc4"), };//数组

	    IEnumerable<Myclass> Quarys = from Myclass mc in array    select mc;//从集合中选取每一个对象

            foreach(Myclass mc in Quarys)
            {
                WriteLine(mc.ToString());
                                        //xooos1 1 desc1
                                        //xooos2 2 desc2
                                        //xooos2 3 desc3
                                        //xooos3 4 desc4
                                        //xooos3 4 desc4
            }
}

4）group by子句：可选的，用来指定选定的项如何被分组。
	    
             语法： group 单个元素引用变量 by 引用变量的属性

	     注意事项如下：
 
	     （1）如果项包括在查询的结果中，就可以根据某个字段的值进行分组。作为分组依据的项叫做键；

	     （2）group子句不从原始的数据源中返回可枚举项的枚举类型，而是返回已经形成的可以枚举项的分组的可枚举类型；

	     （3）分组本身是可枚举类型，它们可以枚举实际的项。


public static void Main(string[] args){//测试

            Myclass[] array = new Myclass[] {new Myclass("xooos1",1,"desc1"), new Myclass("xooos2", 2, "desc2"), 
                              new Myclass("xooos2",3, "desc3"), new Myclass("xooos3",4, "desc4"), new Myclass("xooos3",4, "desc4"), };//数组

	    IEnumerable< IGrouping<string, Myclass> > Quarys = from Myclass mc in array    group mc by mc.name;//按照姓名分组

            foreach( IGrouping<string, Myclass> ig in Quarys ) // 集合分组后的每一个元素是一个键值对
            {
                foreach (var s in ig)
                {
                    WriteLine(s.name);
                }
            }
}

5）orderby子句：接受一个表达式并根据表达式依次返回结果项
	    
             语法：orderby 表达式 [ascending升序默认|descending降序] 

	     不写后缀默认是升序排序方式,可以有任意多个orderby子句，但是必须使用逗号分割。

public static void Main(string[] args){//测试

            Myclass[] array = new Myclass[] {new Myclass("xooos1",14,"desc1"), new Myclass("xooos2", 29, "desc2"), 
                              new Myclass("xooos2",65, "desc3"), new Myclass("xooos3",567, "desc4"), new Myclass("xooos3",134, "desc4"), };//数组


            IOrderedEnumerable<Myclass> myclasses = from Myclass mc in array orderby mc.age descending select mc;//降序排列

            foreach(Myclass mc in myclasses)
            {   
                WriteLine(mc.age);//567 134 65 29 14
                
            }
}

----------------------------------------------
扩展方法:实现IEnumerable接口的类都能用的扩展方法。

1.where()筛选

public static void Main(string[] args){//测试

            Myclass[] array = new Myclass[] {new Myclass("xooos1",14,"desc1"), new Myclass("xooos2", 29, "desc2"), 
                              new Myclass("xooos2",65, "desc3"), new Myclass("xooos3",567, "desc4"), new Myclass("xooos3",134, "desc4"), };//数组

	    IEnumerable<Myclass> enumerable = array.Where(mc => {return mc.age > 100;});  //array的扩展方法where()

            foreach (Myclass mc in enumerable)
            {   
                WriteLine(mc.age);//567 134
            }
}

 进阶：
 where() 用索引index筛选：

 public static void Main(string[] args){//测试

            Myclass[] array = new Myclass[] {new Myclass("xooos1",14,"desc1"), new Myclass("xooos2", 29, "desc2"), 
                              new Myclass("xooos2",65, "desc3"), new Myclass("xooos3",567, "desc4"), new Myclass("xooos3",134, "desc4"), };//数组


            IEnumerable<Myclass> enumerable = array.Where( (mc,index) => {return mc.age > 100&&index%2==0;});//索引作为一个参数，筛选年龄大于100且集合下标为偶数的元素

            foreach (Myclass mc in enumerable)
            {   
                WriteLine(mc.age);
                
            }
}
 进阶：类型筛选：OfType<T>()方法

 public static void Main(string[] args){//测试

            object[] array={ 1,2,3,"xooos1","xooos2","xooos3"};

            IEnumerable<string> enumerable = array.OfType<string>();//筛选出只是字符串的元素

            foreach(string s in enumerable)
            {
                WriteLine(s);
                            //xooos1
                            //xooos2
                            //xooos3
            }
        }
2.复合的from从句(集合中的各个元素的某个属性也为一个集合，想要以属性集合中的元素为判断依据)

  两种实现方式：

      两个from in的基本使用：

      public static void Main(string[] args){//测试 
		Myclass[] myclasses = new Myclass[] { new Myclass("xooos1", new List<string> { "a", "b", "c" }), new Myclass("xooos2", new List<string> { "d", "e", "f" }),

                new Myclass("xooos3", new List<string> { "g", "h", "i" }), new Myclass("xooos4", new List<string> { "j", "k", "l" }), 

                new Myclass("xooos5", new List<string> { "m", "n", "p" }), };

                                   //取得源集合，元素为多个Myclass  //取得第二个源集合，元素为多个字符串        //利用两个源集合的所有元素 相互组合形成多个对象
                var enumerable = from Myclass mc in myclasses   from string s in mc.mylist           select new { name = mc.name, desc = s };

                foreach(var v in enumerable)
                {
                WriteLine(v.name + "  " + v.desc);
                                                    //xooos1 a
                                                    //xooos1 b
                                                    //xooos1 c
                                                    //xooos2 d
                                                    //xooos2 e
                                                    //xooos2 f
                                                    //xooos3 g
                                                    //xooos3 h
                                                    //xooos3 i
                                                    //xooos4 j
                                                    //xooos4 k
                                                    //xooos4 l
                                                    //xooos5 m
                                                    //xooos5 n
                                                    //xooos5 p
              }

      }
      	----------------------------------------------

      SelectMany()方法： IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(  Func< TSource,IEnumerable<TCollection> > collectionSelector,

								                        Func< TSource, TCollection, TResult    > resultSelector );

      public static void Main(string[] args){//测试 选出属性数组2的值有3的Myclass对象
            Myclass[] array = new Myclass[] {new Myclass("xooos1",new int[]{ 1,2,3}), new Myclass("xooos2", new int[]{ 4,3,6}),

            new Myclass("xooos3",new int[]{ 7,8,9}), new Myclass("xooos4",new int[]{ 10,3,12}), new Myclass("xooos5",new int[]{ 13,14,15}), };//数组1,数组中的元素还有一个属性是数组2

                                                               //获取集合源，要返回 属性数组2  //数组1的元素 和 数组2的元素 组成多个新匿名的对象  //筛选数组2的元素等于3的新对象
            IEnumerable<string> enumerable = array.SelectMany(mc => { return mc.array; }, (mc, i) => new { myclass = mc, elem = i }).Where(i => { return i.elem == 3; }).Select(mc => mc.myclass.name);

            foreach(string s in enumerable)
            {
                WriteLine(s);
            }
                            //xooos1
                            //xooos2
                            //xooos4
        }
3.OrderByDescending()方法降序排列;还可以用ThenBy()方法再选择一个排序标准。

	public static void Main(string[] args){//测试 

            Myclass[] array = new Myclass[] {new Myclass("xooos1",14,"desc1"), new Myclass("xooos2", 29, "desc2"),
                              new Myclass("xooos2",65, "desc3"), new Myclass("xooos3",567, "desc4"), new Myclass("xooos3",134, "desc4"), };//数组


            IEnumerable<Myclass> enumerable = array.OrderByDescending(mc => { return mc.age; }).Select(mc => mc);//按照年龄降序排列

            foreach(Myclass mc in enumerable)
            {
                Write(mc.age);   //567  134  65  29  14
                Write("  ");
            }
        }
 	
4..GroupBy()分组方法，注意：其返回值是一个键值对。Count()方法统计每个小组的 元素个数。
	
	public static void Main(string[] args){//测试 
            Myclass[] array = new Myclass[] {new Myclass("xooos1",14,"desc1"), new Myclass("xooos2", 29, "desc2"),
                              new Myclass("xooos2",65, "desc3"), new Myclass("xooos3",567, "desc4"), new Myclass("xooos3",134, "desc4"), };//数组


                                   //按照名字分组         //选出键值对的 键和每个分组的数量 构建一个匿名的新对象
            var enumerable = array.GroupBy(mc => mc.name).Select(g=>new { name2=g.Key, count2=g.Count()});
             
            foreach(var v in enumerable)
            {
                WriteLine(v.name2 + "  " + v.count2);//xooos1  1 
                                                     //xooos2  2
                                                     //xooos3  2      //分组的标准及其对应的个数
            }

             
            IEnumerable<string> enumerable = array.GroupBy(mc => mc.name).Select(g => g.Key);//按照名字分组后，取得每个分组的姓名(不重复)

            foreach(string s in enumerable)
            {
                WriteLine(s);
            }
                            //xooos1
                            //xooos2
                            //xooos3
        }

5.内连接

      用法： 现拥有集合1和集合2， from elem1 in 集合1 join elem2 in 集合2  on 集合1.属性X=集合2.属性Y；

示例：
public static void Main(string[] args){//测试 


            Myclass[] myclasses1 = new Myclass[] { new Myclass("xooos1", new List<string> { "a", "b", "c" }), new Myclass("xooos2", new List<string> { "d", "e", "f" }),

                new Myclass("xooos3", new List<string> { "g", "h", "i" }), new Myclass("xooos4", new List<string> { "j", "k", "l" }), 

                new Myclass("xooos5", new List<string> { "m", "n", "p" }), };

                             //取得源集合，元素为多个Myclass        //取得第二个源集合，元素为多个字符串    //利用两个源集合的所有元素 相互组合形成多个对象
            var enumerable1 = from Myclass mc1 in myclasses1   from string s1 in mc1.mylist           select new { name = mc1.name, desc = s1 };

            foreach(var v in enumerable1)
            {
                WriteLine(v.name + "  " + v.desc);
                                                    //xooos1 a
                                                    //xooos1 b
                                                    //xooos1 c
                                                    //xooos2 d
                                                    //xooos2 e
                                                    //xooos2 f
                                                    //xooos3 g
                                                    //xooos3 h
                                                    //xooos3 i
                                                    //xooos4 j
                                                    //xooos4 k
                                                    //xooos4 l
                                                    //xooos5 m
                                                    //xooos5 n
                                                    //xooos5 p
            }
            WriteLine( );
            Myclass[] myclasses2 = new Myclass[] { new Myclass("xooos3", new List<string> { "a", "b", "c" }), new Myclass("xooos4", new List<string> { "d", "e", "f" }),

                new Myclass("xooos5", new List<string> { "g", "h", "i" }), new Myclass("xooos6", new List<string> { "j", "k", "l" }),

                new Myclass("xooos6", new List<string> { "m", "n", "p" }), };

                              //取得源集合，元素为多个Myclass       //取得第二个源集合，元素为多个字符串    //利用两个源集合的所有元素 相互组合形成多个对象
            var enumerable2 = from Myclass mc2 in myclasses2   from string s2 in mc2.mylist     select new { name = mc2.name, desc = s2 };
            foreach (var v in enumerable2)
            {
                WriteLine(v.name + "  " + v.desc);
                                                //xooos3 a
                                                //xooos3 b
                                                //xooos3 c
                                                //xooos4 d
                                                //xooos4 e
                                                //xooos4 f
                                                //xooos5 g
                                                //xooos5 h
                                                //xooos5 i
                                                //xooos6 j
                                                //xooos6 k
                                                //xooos6 l
                                                //xooos6 m
                                                //xooos6 n
                                                //xooos6 p
            }

            WriteLine();

            var enumerable = from newinstance1 in enumerable1  //内连接，基于集合1的姓名等于集合2的姓名，两个集合的连接

                             join newinstance2 in enumerable2

                             on newinstance1.name equals newinstance2.name

                             select new { name = newinstance1.name, desc1 = newinstance1.desc, desc2 = newinstance2.desc };


            foreach(var v in enumerable)
            {
                WriteLine(v.name + " " + v.desc1 + " " + v.desc2);
                                                                                //xooos3 g a
                                                                                //xooos3 g b
                                                                                //xooos3 g c
                                                                                //xooos3 h a
                                                                                //xooos3 h b
                                                                                //xooos3 h c
                                                                                //xooos3 i a
                                                                                //xooos3 i b
                                                                                //xooos3 i c
                                                                                //xooos4 j d
                                                                                //xooos4 j e
                                                                                //xooos4 j f
                                                                                //xooos4 k d
                                                                                //xooos4 k e
                                                                                //xooos4 k f
                                                                                //xooos4 l d
                                                                                //xooos4 l e
                                                                                //xooos4 l f
                                                                                //xooos5 m g
                                                                                //xooos5 m h
                                                                                //xooos5 m i
                                                                                //xooos5 n g
                                                                                //xooos5 n h
                                                                                //xooos5 n i
                                                                                //xooos5 p g
                                                                                //xooos5 p h
                                                                                //xooos5 p i
            }

6.左外连接

var enumerable =                		 from newinstance1 in enumerable1

                                                 join newinstance2 in enumerable2

                                                 on newinstance1.name equals newinstance2.name

                                                 into left from newinstance2 in left.DefaultIfEmpty() //左连接写法

                                                 select new { name = newinstance1.name, desc1 = newinstance1.desc, desc2 = newinstance2?.desc };//注意空指针


                foreach(var v in enumerable)
                {
                    WriteLine(v.name + " " + v.desc1 + " " + v.desc2);
									//xooos1 a
									//xooos1 b
									//xooos1 c
									//xooos2 d
									//xooos2 e
									//xooos2 f
									//xooos3 g a
									//xooos3 g b
									//xooos3 g c
									//xooos3 h a
									//xooos3 h b
									//xooos3 h c
									//xooos3 i a
									//xooos3 i b
									//xooos3 i c
									//xooos4 j d
									//xooos4 j e
									//xooos4 j f
									//xooos4 k d
									//xooos4 k e
									//xooos4 k f
									//xooos4 l d
									//xooos4 l e
									//xooos4 l f
									//xooos5 m g
									//xooos5 m h
									//xooos5 m i
									//xooos5 n g
									//xooos5 n h
									//xooos5 n i
									//xooos5 p g
									//xooos5 p h
									//xooos5 p i
	
                                                                                   
                }
--------------------------------------------------------------------------------------------------------------------------------------------------------
32.异常

1.异常过滤器：when
 public class Myexception : Exception //自定义异常
    {
        public int Errorcode;

        public Myexception(int errorcode)
        {
            Errorcode = errorcode;
        }
    }


  public static void Main(string[] args){//测试 

                try { throw new Myexception(400); }

                catch(Myexception e) when (e.Errorcode==401)//过滤器，满足when的才会执行catch块。
                {   

                    WriteLine(e.Message+" "+e.Errorcode)
                    ;
                }
                catch (Exception e)
                {

                    WriteLine(e.Message +"  "+"第二个catch" );
                }
}
---------------------------------------------------------



--------------------------------------------------------------------------------------------------------------------------------------------------------
C#MVC：

1.MVC 根据传入 URL 调用不同的控制器类 () 和它们中的不同操作方法。 https://localhost:44325/helloworld/Welcome --->调用Welcome方法。

							http://localhost:xxxx/HelloWorld/Welcome?name=Scott&numtimes=4 --->调用Welcome方法含参数的方法。

2.错误记录1：Newtonsoft.Json不匹配？  解决方法：Web.config文件中将对应地方改为 <bindingRedirect oldVersion="0.0.0.0-12.0.0.0" newVersion="12.0.0.0" /> 12版本与bin目录下的Newtonsoft.Json.dll文件的版本一样。

  错误记录2：controllers包无法创建新的控制器？ 解决方法：搜索 管理NuGet程序包，EntityFramework这个包没有就装上；有就卸了重装。 注意：这也是shared文件夹没有_Layout.cshtml 文件的原因(好像不是，创建项目时，可以选择低版本的.net框架)。
  
  错误记录3：两个index方法冲突，将某个index添加[httpGet]或[httpPost]
3._Layout.cshtml 文件。 此文件称为 布局页 ，位于所有其他页面使用的共享文件夹中。

---------------------------------------
   _Layout.cshtml 布局文件： (注意：页面的完整的结果最终是布局文件的效果)

  <!DOCTYPE html>

  <html>
  <head>
      <meta name="viewport" content="width=device-width" />
      <title>@ViewBag.Title 厉害</title>
  </head>
  <body>
      <div>
          句子1
          @RenderBody() //就是其相关页面的body部分
          句子2
      </div>
  </body>
  </html>

---------------------------------------
  index.cshtml页面文件:

  @{
      Layout = "~/Views/Shared/_LayoutPage.cshtml"; //连接模板布局文件_LayoutPage.cshtml
   }
  @{
      ViewBag.Title = "第一个视图";                   //ViewBag.Title将值传递到 布局文件的 @ViewBag.Title中
   }

  ---------------------------------
  <h2>Index</h2>		//@RenderBody()显示的内容

  <p>Welcome to .net</p>	//@RenderBody()显示的内容
  ---------------------------------

---------------------------------------

4.控制层接受网页的参数 用于页面显示。

请求：https://localhost:44332/helloworld/index?s=stepback&i=10

public class helloworldController : Controller //控制层
    {
        
        public ActionResult Index(string s,int i) //处理方法 
        {
            ViewBag.name = s.ToUpper();                     //接受并处理参数，比如将字符串全改为大写
            ViewBag.num = i;			  //接受并处理参数
            return View();                        //返回页面
        }
    }

index.cshtml页面文件:

<h2>Index</h2>
<p>Welcome to .net</p>
<p>
    @for (int i = 0; i < ViewBag.num; i++)
        {
         
           @ViewBag.name  @ViewBag.num             //数据用于页面展示
           <br />
        }
</p>


5.连接数据库LocalDB

LocalDB：是SQL Server Express数据库引擎的轻型版本，可按需启动并在用户模式下运行。

        LocalDB 以SQL Server Express的特殊执行模式运行，使你可以将数据库用作 .mdf 文件。 

        通常，LocalDB 数据库文件保存在 Web 项目的 App_Data 文件夹中。

6.根据实体类(模型层)自动生成控制层、视图层	

7.连接复原能力和命令拦截。 它们是 Entity Framework 6 的两个重要功能，在部署到云环境时尤其有用：连接复原 (自动重试暂时性错误) 

  和命令截获 (捕获发送到数据库的所有 SQL 查询，以便记录或更改它们) 。

  云服务通常由其他用户共享，这意味着其响应能力可能会受到它们的影响。 对数据库的访问可能会受到限制。 限制意味着数据库服务在尝试访问它的频率比服务级别协议 (SLA) 中允许的频率更高时引发异常。

  访问云服务时，许多或大多数连接问题都是暂时性的，即在短时间内自行解决。 因此，尝试数据库操作并获取通常是暂时性的错误类型时，可以在短暂等待后再次尝试该操作，并且操作可能会成功。 如果通过自动尝试处理  
  暂时性错误，使大多数错误对客户不可见，可以为用户提供更好的体验。 Entity Framework 6 中的连接复原功能可自动执行重试失败的 SQL 查询的过程。



















